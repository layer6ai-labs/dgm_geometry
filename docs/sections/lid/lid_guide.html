<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Hamidreza Kamkari">

<title>Using our LID Estimators – Geometry of Deep Generative Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Geometry of Deep Generative Models</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../sections/ood.html" aria-current="page"> 
<span class="menu-text">Out-of-distribution detection</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sections/lid.html"> 
<span class="menu-text">Local Intrinsic Dimension</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/layer6ai-labs/dgm_geometry" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../sections/lid.html">Local Intrinsic Dimension</a></li><li class="breadcrumb-item"><a href="../../sections/lid/lid_guide.html">Using our LID Estimators</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../sections/ood.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Out-of-distribution detection</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../sections/ood/ood_guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">A Hands-on Guide</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../sections/lid.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Local Intrinsic Dimension</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../sections/lid/manifold_datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Manifold Datasets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../sections/lid/lid_guide.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Using our LID Estimators</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../sections/lid/flipd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fokker-Planck LID (FLIPD)</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#model-free-estimators" id="toc-model-free-estimators" class="nav-link active" data-scroll-target="#model-free-estimators"><span class="header-section-number">1</span> Model-Free Estimators</a>
  <ul class="collapse">
  <li><a href="#how-to-interpret-the-output" id="toc-how-to-interpret-the-output" class="nav-link" data-scroll-target="#how-to-interpret-the-output"><span class="header-section-number">1.1</span> How to interpret the output</a></li>
  <li><a href="#how-to-tweak-the-setting" id="toc-how-to-tweak-the-setting" class="nav-link" data-scroll-target="#how-to-tweak-the-setting"><span class="header-section-number">1.2</span> How to tweak the setting</a></li>
  </ul></li>
  <li><a href="#model-based-estimators-using-scripts" id="toc-model-based-estimators-using-scripts" class="nav-link" data-scroll-target="#model-based-estimators-using-scripts"><span class="header-section-number">2</span> Model-based Estimators (using <code>scripts</code>)</a>
  <ul class="collapse">
  <li><a href="#flow-estimators-using-the-jacobian-of-the-flow-push-forward" id="toc-flow-estimators-using-the-jacobian-of-the-flow-push-forward" class="nav-link" data-scroll-target="#flow-estimators-using-the-jacobian-of-the-flow-push-forward"><span class="header-section-number">2.1</span> Flow Estimators: Using the Jacobian of the Flow Push-Forward</a></li>
  <li><a href="#diffusion-estimators-using-the-score-function" id="toc-diffusion-estimators-using-the-score-function" class="nav-link" data-scroll-target="#diffusion-estimators-using-the-score-function"><span class="header-section-number">2.2</span> Diffusion Estimators: Using the Score Function</a></li>
  <li><a href="#fokker-planck-estimator-flipd-coming-soon" id="toc-fokker-planck-estimator-flipd-coming-soon" class="nav-link" data-scroll-target="#fokker-planck-estimator-flipd-coming-soon"><span class="header-section-number">2.3</span> Fokker Planck Estimator (FLIPD: Coming soon!)</a></li>
  <li><a href="#lidl-estimator" id="toc-lidl-estimator" class="nav-link" data-scroll-target="#lidl-estimator"><span class="header-section-number">2.4</span> LIDL Estimator</a></li>
  <li><a href="#stacking-the-lid-estimator-callbacks" id="toc-stacking-the-lid-estimator-callbacks" class="nav-link" data-scroll-target="#stacking-the-lid-estimator-callbacks"><span class="header-section-number">2.5</span> Stacking the LID Estimator Callbacks</a></li>
  </ul></li>
  <li><a href="#model-based-estimators-using-python-sdk" id="toc-model-based-estimators-using-python-sdk" class="nav-link" data-scroll-target="#model-based-estimators-using-python-sdk"><span class="header-section-number">3</span> Model-based Estimators (using python SDK)</a>
  <ul class="collapse">
  <li><a href="#a-model-free-estimator" id="toc-a-model-free-estimator" class="nav-link" data-scroll-target="#a-model-free-estimator"><span class="header-section-number">3.1</span> A model-free estimator</a></li>
  <li><a href="#a-model-based-estimator" id="toc-a-model-based-estimator" class="nav-link" data-scroll-target="#a-model-based-estimator"><span class="header-section-number">3.2</span> A Model-based estimator</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../sections/lid.html">Local Intrinsic Dimension</a></li><li class="breadcrumb-item"><a href="../../sections/lid/lid_guide.html">Using our LID Estimators</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Using our LID Estimators</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Hamidreza Kamkari </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>This Notebook guides you through the process of using our LID estimators. We deal with two different types of LID estiamtors: (1) ones that require training or fitting a deep generative model (or can alternatively use a pre-trained one), and (2) traditional LID estiamtors that are “model-free” and do not require training. Let us go over them one by one, but before we do, make sure to run the following cell to initialize the notebook first and take a look at the <a href="./manifold_datasets.html">manifold dataset</a> notebook that contains our manifold datasets where we have access to the underlying manifold with the ground truth LID.</p>
<div id="cell-2" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> notebook_setup <span class="im">import</span> device</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda:0"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="model-free-estimators" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="model-free-estimators"><span class="header-section-number">1</span> Model-Free Estimators</h2>
<p>Common model-free LID estimators are lPCA, ESS, and MLE. To run model-free estimators, setup your mlflow and run scripts in the following format:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=<span class="op">&lt;</span>dataset<span class="op">&gt;</span> lid_method=<span class="op">&lt;</span>lid-method<span class="op">&gt;</span> +experiment=<span class="op">&lt;</span>lid_greyscale <span class="kw">|</span> <span class="ex">lid_rgb</span> <span class="kw">|</span> <span class="ex">lid_tabular</span><span class="op">&gt;</span> subsample_size=<span class="op">&lt;</span>subsample-size<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Explanation of the arguments:</p>
<ol type="1">
<li><code>dataset</code>: The dataset to run the LID estimator on. We have an extensive suite of datasets including <code>lollipop</code>, <code>swiss_roll</code>, <code>cifar10</code>, <code>mnist</code>, to name a few. To see the full list, check out the <code>conf/datasets</code> directory of the codebase.</li>
<li><code>lid_method</code>: The LID estimator to run. The available LID estimators include <code>lpca</code>, <code>ess</code>, and <code>mle</code> to name a few.</li>
<li><code>experiment_dir</code>: The directory to save the experiment outputs. The available directories include <code>lid_greyscale</code>, <code>lid_rgb</code>, and <code>lid_tabular</code> for grayscale (28x28), RGB (3x32x32), and tabular datasets, respectively.</li>
<li><code>subsample_size</code>: This performs a subsampling of the dataset to the specified size. This is useful for high-dimensional datasets like CIFAR-10 and MNIST where computing these model-free estimators is intractable for the entire dataset.</li>
</ol>
<p>Example runs:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Lollipop runs:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=lollipop lid_method=ess +experiment=lid_tabular subsample_size=10000</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=lollipop lid_method=lpca +experiment=lid_tabular subsample_size=10000</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Image Greyscale runs</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=mnist lid_method=ess +experiment=lid_greyscale subsample_size=4096</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=fmnist lid_method=lpca +experiment=lid_greyscale subsample_size=4096</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Image RGB runs</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=cifar10 lid_method=ess +experiment=lid_rgb subsample_size=4096</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="how-to-interpret-the-output" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="how-to-interpret-the-output"><span class="header-section-number">1.1</span> How to interpret the output</h3>
<p>You should first setup your Mlflow server. Then, you can visualize the outputs for each of these runs. The outputs include the following:</p>
<ol type="1">
<li><strong>Estimation heatmap</strong>: For a holistic view, these scripts will log the UMAP embedding of all the dataset and for each point, they will log the estimated value of LID in the <code>lid_image/heatmap_pred.png</code> file in the artifacts and the true LIDs (if available) will be logged <code>lid_image/heatmap_gt.png</code> file in the artifacts. For example, the images will not have a ground truth files. You can also set the run to not log the heatmap by setting <code>visualize_manifold=null</code>.</li>
<li><strong>Detailed evaluation</strong>: A detailed evaluation of the LID estimator is logged in the <code>results.yaml</code> file in the artifacts. This includes the mean absolute error, mean squared error, concordance index, and many other summary statistics to show how well the LID estimator performed. In cases where the ground truth is not available, you can check the average estimated LID values to see how well the LID estimator performed. You can also see how well the LID estimator performs on each individual submanifold for datasets with multiple known submanifolds (such as lollipop).</li>
<li><strong>Raw prediction</strong>: To perform any additional analysis, the raw predictions are also logged in the <code>prediction.csv</code> file in the artifacts that you can download and analyze.</li>
</ol>
</section>
<section id="how-to-tweak-the-setting" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="how-to-tweak-the-setting"><span class="header-section-number">1.2</span> How to tweak the setting</h3>
<p>As with the rest of the codebase, we use Hydra and one can tweak the configurations above in the command-line. For example, you can set the time hyperparameter of <code>ess</code> to another value that works better:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># increase the number of neighbours for the estimator</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/model_free_lid.py dataset=fmnist lid_method=lpca +experiment=lid_greyscale subsample_size=10000 lid_method.preprocess_args.n_neighbours=1000</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For a more detailed look, you can take a look at the appropriate Hydra configurations in the <code>conf/lid_method/</code> directory.</p>
</section>
</section>
<section id="model-based-estimators-using-scripts" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="model-based-estimators-using-scripts"><span class="header-section-number">2</span> Model-based Estimators (using <code>scripts</code>)</h2>
<p>Similar to the scripts we use for model-free estimators, we have scripts for model-based estimators. Since the model-based estimators require training a deep generative model, these estimators have been developed as a lightning callback to monitor the LID during training. In case, you want to use your pre-trained model, you can simply set the checkpoint argument. For example, we have already included checkpoints for FMNIST/MNIST/CIFAR-10/SVHN, and if you run <code>scripts/download_resources.py</code> they should already be downloaded for you. A simple example would be to run the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=mnist +experiment=train_flow_greyscale +checkpoint=flow_mnist +callbacks@all_callbacks.monitor_lid=flow_jacobian_threshold_lid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This script uses a pre-trained normalizing flow on MNIST images and employs the Jacobian of the flow push-forward for each individual datapoint to estimate LID. Specifically, it examines the singular values of this Jacobian and uses the threshold <span class="math inline">\tau</span> to determine the intrinsic dimension, defined as the number of singular values exceeding the threshold. For more information on this estimator, refer to our paper <span class="citation" data-cites="kamkari2024oodlid">(<a href="#ref-kamkari2024oodlid" role="doc-biblioref">Kamkari, Ross, Cresswell, et al. 2024</a>)</span>.</p>
<p>After running the script, you can check the artifact directory of MLFlow. You will find a folder named <code>MultiMetrics</code>, which contains a <code>metrics=xxx.csv</code> file. This file includes a column with the estimated LID values for each datapoint. Additionally, you can explore the <code>samples</code> sub-directory to see the samples for which LID was evaluated. A list of all the callbacks are available in the <code>conf/callbacks</code> directory where you can invoke other LID estimators as well.</p>
<p>Before we dive into the details of each estimator, let’s first cover some of the basic things that <em>all</em> of these callbacks log:</p>
<ol type="1">
<li><p><strong>Data summary</strong>: The callback logs the data summary in the <code>{logging_folder_name}/manifold_info.csv</code> file in the artifacts directory. This will include all the subsampled datapoints information. If for example, these are from synthetic data where the manifold structure is known, then the columns <code>lid</code> and <code>submanifold</code> will contain the true LID values and the submanifold labels respectively. If not, then these columns will be filled by <code>-1</code> and <code>0</code> respectively; this for example happens with image datasets.</p></li>
<li><p><strong>Seeing samples</strong>: All the samples will be logged in <code>{logging_folder_name}/samples/</code> directory. It will be either a <code>.csv</code> file if the data is tabular and a set of <code>.png</code> and <code>.npy</code> files if the data is an image. In addition to that, each sample has a transformed and an untransformed version. This is because the DGM also has a set of post-hoc transformations that are applied after the DGM generates the samples.</p></li>
<li><p><strong>Evaluating</strong>: In all of the monitoring callbacks where a csv file is stored that contains information about all the datapoints, the index of the data (the row it resides in) is consistent with the row in the <code>{logging_folder_name}/manifold_info.csv</code>. Thus, you can join tables and evaluate the performance of LID estimators on a per-sample basis if you want to.</p></li>
</ol>
<p>Now let’s dive into each individual estimator:</p>
<section id="flow-estimators-using-the-jacobian-of-the-flow-push-forward" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="flow-estimators-using-the-jacobian-of-the-flow-push-forward"><span class="header-section-number">2.1</span> Flow Estimators: Using the Jacobian of the Flow Push-Forward</h3>
<p>This estimator is tailored towards normalizing flows where the mapping from the latent space to the data space is easy to acces and differentiate. All of them work by computing the Jacobian of the flow push-forward for each individual datapoint and estimating the LID based on this Jacobian. Both of them use some sort of scale parameter <span class="math inline">\tau</span> to determine the intrinsic dimensionality of the manifold. After running the following scripts, you should be able to reproduce the following curves, indicating the estimated LID for each individual datapoint as a function of <span class="math inline">\log \tau</span>.</p>
<div id="cell-fig-lid-curve-flow" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dotenv</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization.pretty <span class="im">import</span> ColorTheme</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization.trend <span class="im">import</span> plot_trends</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># load the environment variables</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>dotenv.load_dotenv(override<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_lid_curve(</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    ax, </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    artifact_dir: <span class="bu">str</span>, </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    title: <span class="bu">str</span>, </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    method_name: <span class="bu">str</span>,</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    label: <span class="bu">str</span>,</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.01</span>, </span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"Sweeping argument"</span>, </span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    y_label<span class="op">=</span><span class="st">"LID"</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find the directory {artifact_dir}/likelihood_generated/metrics=xxx.csv`</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    lid_curve_dir <span class="op">=</span> os.path.join(artifact_dir, method_name, <span class="st">"trends"</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    trend_files <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(lid_curve_dir) <span class="cf">if</span> re.match(<span class="vs">r'trend_epoch=\d+\.csv'</span>, f)][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    trend_in <span class="op">=</span> pd.read_csv(os.path.join(lid_curve_dir, trend_files), index_col<span class="op">=</span><span class="dv">0</span>).values</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    sweeping_args_file <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(lid_curve_dir) <span class="cf">if</span> f.startswith(<span class="st">"sweeping_range"</span>)][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    sweeping_args_df <span class="op">=</span> pd.read_csv(os.path.join(lid_curve_dir, sweeping_args_file), index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    sweeping_arg <span class="op">=</span> sweeping_args_df.columns[<span class="dv">0</span>]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    sweeping_values <span class="op">=</span> sweeping_args_df[sweeping_arg].values</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(trend_in.shape[<span class="dv">0</span>]):</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        ax.plot(sweeping_values, trend_in[i], color<span class="op">=</span>ColorTheme.BLUE_FIRST.value, alpha<span class="op">=</span>alpha)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    ax.plot([], [], color<span class="op">=</span>ColorTheme.BLUE_SECOND.value, label<span class="op">=</span>label)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(x_label)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(y_label)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>visualize_lid_curve(</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axs[<span class="dv">0</span>],</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    artifact_dir<span class="op">=</span>os.getenv(<span class="st">"LID_FLOW_JACOBIAN_THRESHOLD_MNIST"</span>),</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"LID as a function of the singular value threshold"</span>,</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    method_name<span class="op">=</span><span class="st">"JacobianThresholdEstimatorCurve"</span>,</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.08</span>,</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">log </span><span class="ch">\\</span><span class="st">tau$"</span>,</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"MNIST Data"</span>,</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>visualize_lid_curve(</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axs[<span class="dv">1</span>],</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    artifact_dir<span class="op">=</span>os.getenv(<span class="st">"LID_FLOW_FAST_LIDL_MNIST"</span>),</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    method_name<span class="op">=</span><span class="st">"FastFlowLIDLCurve"</span>,</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"LID as a function of LIDL scale"</span>,</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.08</span>,</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">delta </span><span class="ch">\\</span><span class="st">approx </span><span class="ch">\\</span><span class="st">log </span><span class="ch">\\</span><span class="st">tau$"</span>,</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"MNIST Data"</span>,</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(pad<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-lid-curve-flow" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lid-curve-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lid_guide_files/figure-html/fig-lid-curve-flow-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lid-curve-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Visualizing the LID curve of flow-based estimators, the left plot shows the LID curve of the Jacobian threshold estimator on the MNIST dataset, while the right plot shows the LID curve of the fast LIDL estimator. Both plateau at a certain range of the sweeping argument.
</figcaption>
</figure>
</div>
</div>
</div>
<section id="the-jacobian-threshold-estimator" class="level4" data-number="2.1.1">
<h4 data-number="2.1.1" class="anchored" data-anchor-id="the-jacobian-threshold-estimator"><span class="header-section-number">2.1.1</span> The Jacobian Threshold Estimator</h4>
<p>This estimator simply computes the singular values of the Jacobian and uses a threshold for which all the singular values above that correspond to on-manifold directions. This estimator can also entail an LID curve: showing for each individual datapoint, the LID estimate as a function of the threshold, this will give a more holistic view of the manifold locally around each datapoint. To run this LID curve, for example on the MNIST dataset, run the following command:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set a smaller subsample size to make the run faster</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=mnist +experiment=train_flow_greyscale +checkpoint=flow_mnist +callbacks@all_callbacks.monitor_lid=flow_jacobian_threshold_lid_curve all_callbacks.monitor_lid.subsample_size=128</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dotenv</span> set LID_FLOW_JACOBIAN_THRESHOLD_MNIST <span class="st">"&lt;artifact-dir&gt;"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Or the following for a lollipop dataset:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># this might take some time because it will also train a model</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=lollipop +experiment=train_flow_tabular train.trainer.max_epochs=3   +callbacks@all_callbacks.monitor_lid=flow_jacobian_threshold_lid_curve</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dotenv</span> set LID_FLOW_JACOBIAN_THRESHOLD_LOLLIPOP <span class="op">&lt;</span>artifact-dir<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The following piece of code will visualize the LID curve as well as the estimates for a calibrated value of threshold <span class="math inline">\tau</span> on the Lollipop dataset.</p>
<div id="cell-fig-lid-curve-flow-lollipop" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load the environment variables</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dotenv</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>dotenv.load_dotenv(override<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization.pretty <span class="im">import</span> ColorTheme</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_scatterplot(</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    ax, </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    artifact_dir: <span class="bu">str</span>, </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    title: <span class="bu">str</span>, </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    method_name: <span class="bu">str</span>,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    label: <span class="bu">str</span>,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.01</span>, </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find the directory {artifact_dir}/likelihood_generated/metrics=xxx.csv`</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    lid_curve_dir <span class="op">=</span> os.path.join(artifact_dir, method_name, <span class="st">"trends"</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    trend_files <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(lid_curve_dir) <span class="cf">if</span> re.match(<span class="vs">r'trend_epoch=\d+\.csv'</span>, f)][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    trend_in <span class="op">=</span> pd.read_csv(os.path.join(lid_curve_dir, trend_files), index_col<span class="op">=</span><span class="dv">0</span>).values</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    sweeping_args_file <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> os.listdir(lid_curve_dir) <span class="cf">if</span> f.startswith(<span class="st">"sweeping_range"</span>)][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    sweeping_args_df <span class="op">=</span> pd.read_csv(os.path.join(lid_curve_dir, sweeping_args_file), index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    sweeping_arg <span class="op">=</span> sweeping_args_df.columns[<span class="dv">0</span>]</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    sweeping_values <span class="op">=</span> sweeping_args_df[sweeping_arg].values</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find the index that has sweeping_values close to -4</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> np.<span class="bu">abs</span>(sweeping_values <span class="op">+</span> <span class="dv">4</span>).argmin()</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> pd.read_csv(os.path.join(artifact_dir, method_name, <span class="st">"samples"</span>, <span class="st">"datapoints.csv"</span>), index_col<span class="op">=</span><span class="dv">0</span>).values</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    lid_values <span class="op">=</span> trend_in[:, idx]</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># createa a scatterplot of points with each point being colored by the LID value</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    ax.scatter(points[:, <span class="dv">0</span>], points[:, <span class="dv">1</span>], c<span class="op">=</span>lid_values, cmap<span class="op">=</span><span class="st">"viridis"</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># also show the colorbar</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    cbar <span class="op">=</span> plt.colorbar(ax.collections[<span class="dv">0</span>], ax<span class="op">=</span>ax)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    cbar.set_label(<span class="st">"LID"</span>)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>visualize_lid_curve(</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axs[<span class="dv">0</span>],</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    artifact_dir<span class="op">=</span>os.getenv(<span class="st">"LID_FLOW_JACOBIAN_THRESHOLD_LOLLIPOP"</span>),</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"LID as a function of the threshold"</span>,</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    method_name<span class="op">=</span><span class="st">"JacobianThresholdEstimatorCurve"</span>,</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.01</span>,</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Lollipop Data"</span>,</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">log </span><span class="ch">\\</span><span class="st">tau$"</span>,</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].axvline(x<span class="op">=-</span><span class="dv">4</span>, color<span class="op">=</span>ColorTheme.PIRATE_GOLD.value, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>visualize_scatterplot(</span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axs[<span class="dv">1</span>],</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    artifact_dir<span class="op">=</span>os.getenv(<span class="st">"LID_FLOW_JACOBIAN_THRESHOLD_LOLLIPOP"</span>),</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    method_name<span class="op">=</span><span class="st">"JacobianThresholdEstimatorCurve"</span>,</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"LID Estiamtes for lollipop"</span>,</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.08</span>,</span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">"Lollipop Data"</span>,</span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(pad<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-lid-curve-flow-lollipop" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lid-curve-flow-lollipop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lid_guide_files/figure-html/fig-lid-curve-flow-lollipop-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lid-curve-flow-lollipop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Visualzing the LID curve and estimates of the flow-based method for the lollipop dataset. The left plot shows the LID curve of the Jacobian threshold estimator, where you can see different clusters of data. At a given threshold <span class="math inline">\tau=-4</span> it seems that a cluster of points estimate LID=2, a cluster LID=1, and a cluster LID=0. The right plot shows the LID estimates of these points on a scatterplot, indeed, showing that the ones on the stick are estimated as 1, the ones on the candy as 2, and the ones on the isolated point are estimated as 0.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="fast-flow-lidl-advanced" class="level4" data-number="2.1.2">
<h4 data-number="2.1.2" class="anchored" data-anchor-id="fast-flow-lidl-advanced"><span class="header-section-number">2.1.2</span> Fast Flow LIDL (Advanced)</h4>
<p>This is a continuous proxy for the Jacobian threshold approach. It is based on <a href="https://arxiv.org/abs/2206.14882">Tempczyk et al.</a> (LIDL) and <a href="https://openreview.net/pdf?id=jQ596tXT3k">Kamkari et al.</a>, which is a previous version of <span class="citation" data-cites="kamkari2024oodlid">(<a href="#ref-kamkari2024oodlid" role="doc-biblioref">Kamkari, Ross, Cresswell, et al. 2024</a>)</span> and the LID is approximated by a continuous proxy of the Jacobian thresholding. While the thresholding approach is much simpler and promising, the fact that this estimator also produces similar results and is both continuous and differentiable makes it worthwhile mentioning here.</p>
<p>The basic theory stems from LIDL, where LID can be approximated by how fast the log probability of a datapoint washes out as we add more and more Gaussian noise. We refer the reader to the paper for more details, but will state the main results here formally, defining the convolution between a pre-trained density <span class="math inline">p_\theta</span> and a Gaussian with log standard deviation <span class="math inline">r</span> as <span class="math display">\begin{align}
\begin{aligned}
    \varrho_\delta(\mathbf{x})&amp; := [p_\theta(\cdot )* \mathcal{N}(\ \cdot \ ; \mathbf{0}, e^{2\delta}\mathbf{I}_d)](\mathbf{x}) \\
    &amp;=\int p_\theta(\mathbf{x}{-}\mathbf{x}')\mathcal{N}(\mathbf{x}'; \mathbf{0}, e^{2\delta}\mathbf{I}_d) \mathbf{d} \mathbf{x}',
\end{aligned}
\end{align}</span> <span class="citation" data-cites="tempczyk2022lidl">(<a href="#ref-tempczyk2022lidl" role="doc-biblioref">Tempczyk et al. 2022</a>)</span> showed that under mild regularity conditions, for sufficiently negative <span class="math inline">\delta</span> (i.e.&nbsp;small standard deviation), <span class="math display">\begin{equation}
     \log \varrho_{\delta}(\mathbf{x}) = \delta (\text{LID}_\theta(\mathbf{x}) - d) + \mathcal{O}(1).
\end{equation}</span></p>
<p> implies that, for sufficiently negative <span class="math inline">r</span> (corresponding to sufficiently small noise), the rate of change of <span class="math inline">\log \varrho_\delta(\mathbf{x}_0)</span> with respect to <span class="math inline">r</span> can be used to estimate LID, since <span class="math inline">\frac{\partial}{\partial r} \log \varrho_\delta(\mathbf{x}_0) \approx \text{LID}_\theta(\mathbf{x}_0) - d</span>.</p>
<p>In LIDL, estimating <span class="math inline">\varrho_\delta(\mathbf{x}_0)</span> requires training a separate density model for each <span class="math inline">r</span> value of interest. This is computationally expensive. Instead, we propose a way to leverage the properties of NFs to approximate <span class="math inline">\varrho_\delta(\mathbf{x}_0)</span>. We assume that our normalizing flow has trained a push-forward <span class="math inline">f_\theta: \mathcal{Z} \to \mathcal{X}</span> from a latent space <span class="math inline">\mathcal{Z}</span> to the data space <span class="math inline">\mathcal{X}</span>. Given a reference point <span class="math inline">\mathbf{x}_0</span> and using a first order Taylor approximation of <span class="math inline">f_\theta</span> around <span class="math inline">\mathbf{z}_0 = f^{-1}_\theta (\mathbf{x}_0)</span>, we approximate the NF as an affine function <span class="math inline">f_\theta(\mathbf{z}) \approx \mathbf{J}_0 (\mathbf{z} - \mathbf{z}_0) + \mathbf{x}_0</span>, where <span class="math inline">\mathbf{J}_0</span> is the Jacobian of <span class="math inline">f_\theta</span> evaluated at <span class="math inline">\mathbf{z}_0</span> and is tractable by design. Since <span class="math inline">p_\mathcal{Z}</span> is Gaussian and affine transformations of Gaussians remain Gaussian, we can thus approximate <span class="math inline">p_\theta(\mathbf{x})</span> as <span class="math inline">\hat{p}_\theta(\mathbf{x}) \coloneqq \mathcal{N}(\mathbf{x}; \mathbf{x}_0 - \mathbf{J}_0 \mathbf{z}_0, \mathbf{J}_0 \mathbf{J}_0^\top)</span>. While it might at first appear strange to approximate a function <span class="math inline">f_\theta</span> and a density <span class="math inline">p_\theta</span> that we can already evaluate, this approximation makes convolutions analytically tractable. By convolving <span class="math inline">\hat{p}_\theta</span> (instead of <span class="math inline">p_\theta</span>) with a Gaussian, we can approximate <span class="math inline">\varrho_\delta(\mathbf{x}_0)</span> from as</p>
<p><span class="math display">\begin{align}
    \begin{aligned}
        \hat{\varrho}_\delta(\mathbf{x}_0) &amp;\coloneqq \int \hat{p}_\theta(\mathbf{x}_0 - \mathbf{x}) \mathcal{N}(\mathbf{x}; \mathbf{0}, e^{2\delta}\mathbf{I}_d)\mathbf{d} \mathbf{x} \\
        &amp;= \mathcal{N}(\mathbf{x}_0; \mathbf{x}_0 - \mathbf{J}_0 \mathbf{z}_0, \mathbf{J}_0 \mathbf{J}_0^\top + e^{2\delta}\mathbf{I}_d).
    \end{aligned}
\end{align}</span></p>
<p>For a detailed analysis of the quality of this approximation, we refer the reader to the <a href="https://openreview.net/pdf?id=jQ596tXT3k">paper</a>. However, we can now simply compute the derivative of the log-density computed above to obtain an estimator for LID. Note that to have a shared nomanclature with the other components, we will use <span class="math inline">\tau := e^\delta</span> and <span class="math inline">\log \tau \approx \delta</span> whenever we refer to these estimators. There’s an interpretation of <span class="math inline">e^\delta</span> acting as a threshold over the singular values of the Jacobian of the flow push-forward, and the estimator is essentially a <em>continuous and differentiable proxy</em> for the Jacobian threshold estimator.</p>
<p>To run this estimator, for example on the MNIST dataset, run the following command:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=mnist +experiment=train_flow_greyscale +checkpoint=flow_mnist +callbacks@all_callbacks.monitor_lid=fast_flow_lidl_curve all_callbacks.monitor_lid.subsample_size=128</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dotenv</span> set LID_FLOW_FAST_LIDL_MNIST <span class="op">&lt;</span>artifact-dir<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="diffusion-estimators-using-the-score-function" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="diffusion-estimators-using-the-score-function"><span class="header-section-number">2.2</span> Diffusion Estimators: Using the Score Function</h3>
<section id="normal-bundle-estimator" class="level4" data-number="2.2.1">
<h4 data-number="2.2.1" class="anchored" data-anchor-id="normal-bundle-estimator"><span class="header-section-number">2.2.1</span> Normal Bundle Estimator</h4>
<p>This estimator is based on a study by <span class="citation" data-cites="stanczuk2022your">(<a href="#ref-stanczuk2022your" role="doc-biblioref">Stanczuk et al. 2022</a>)</span> where the score function is sampled around the manifold and the LID is estimated based on the normal bundles of the manifold. To run this estimator, for example on the MNIST dataset, run the following command:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># you can change the frequency to control how often during training you want to monitor LID</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=mnist +experiment=train_diffusion_greyscale +checkpoint=diffusion_mnist +callbacks@all_callbacks.monitor_lid=normal_bundle_lid_curve all_callbacks.monitor_lid.subsample_size=128</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dotenv</span> set LID_DIFFUSION_NORMAL_BUNDLE_MNIST <span class="op">&lt;</span>artifact-dir<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="cell-11" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dotenv</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>dotenv.load_dotenv(override<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>visualize_lid_curve(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>axs,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    artifact_dir<span class="op">=</span>os.getenv(<span class="st">"LID_DIFFUSION_NORMAL_BUNDLE_MNIST"</span>),</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"LID Curve for normal bundle estimator"</span>,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    method_name<span class="op">=</span><span class="st">"NormalBundleEstimatorCurve"</span>,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.08</span>,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"$</span><span class="ch">\\</span><span class="st">log </span><span class="ch">\\</span><span class="st">tau$"</span>,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(pad<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lid_guide_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>This will also log an LID curve where for each datapoint the LID is evaluated as a function of a threshold <span class="math inline">\tau</span>. For more information check out the appropriate section in <a href=""></a> that subsantiates how to adapt this method for vairane-preserving diffusion models.</p>
</section>
</section>
<section id="fokker-planck-estimator-flipd-coming-soon" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="fokker-planck-estimator-flipd-coming-soon"><span class="header-section-number">2.3</span> Fokker Planck Estimator (FLIPD: Coming soon!)</h3>
<p>When posted, you can run our estimator <a href="https://arxiv.org/abs/2406.03537">FLIPD</a> <span class="citation" data-cites="kamkari2024flipd">(<a href="#ref-kamkari2024flipd" role="doc-biblioref">Kamkari, Ross, Hosseinzadeh, et al. 2024</a>)</span> here!</p>
</section>
<section id="lidl-estimator" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="lidl-estimator"><span class="header-section-number">2.4</span> LIDL Estimator</h3>
<p>This is a method proposed by <span class="citation" data-cites="tempczyk2022lidl">(<a href="#ref-tempczyk2022lidl" role="doc-biblioref">Tempczyk et al. 2022</a>)</span>. Unlike the other estimators, this one trains an ensemble of density estimation models (typically normalizing flows, but can also be diffusions). Therefore, the LID monitoring for this estimator is a bit different. To run this estimator, for example on the lollipop dataset, run the following command to train an ensemble of 8 models:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=lollipop +experiment=train_lidl_tabular dataset.train.size=4096 dataset.val.size=128 +callbacks@all_callbacks.umap=umap all_callbacks.umap.frequency=1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Note</strong>: Here, the umap callback will actually generate multiple umap embeddings for each of the models in the ensemble.</p>
<p>Additional outputs include:</p>
<ol type="1">
<li><strong>log likelihood of perturbed data</strong>: Every once in a while, the callback will compute the log_prob of all the datapoints for the different models in the ensemble. This is logged in the <code>lid_logs_{estimator_name}/trends/likelihood_trend_epoch={epoch}.png</code> and <code>lid_logs_{estimator_name}/trends/likelihood_trend_epoch={epoch}.csv</code> file where the x-axis are the different noise scales (the logarithm of the standard deviation of the Gaussian) and each trend represents a datapoint with the <code>y-value</code> being the log_prob of the datapoint for the model associated with a specific noise scale.</li>
<li><strong>Regression</strong>: The result of doing a regression on the log_prob of the datapoints is logged in the <code>lid_logs_{estimator_name}/predictions/estimates_{epoch}.csv</code>. As always, the row numbers are consistent with the ones in the <code>manifold_info.csv</code> file. Thus, you can use that to evaluate the performance of LIDL.</li>
</ol>
</section>
<section id="stacking-the-lid-estimator-callbacks" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="stacking-the-lid-estimator-callbacks"><span class="header-section-number">2.5</span> Stacking the LID Estimator Callbacks</h3>
<p>As memtioned before, the LID estimators are implemented as callbacks in PyTorch Lightning. This means that you can stack them together and run them simultaneously to get the best comparison. The following is an example of stacking the Jacobian thresholding and Fast Flow LIDL estimator on lollipop:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> scripts/train.py dataset=lollipop +experiment=train_flow_tabular train.trainer.max_epochs=30 +callbacks@all_callbacks.monitor_lid1=flow_jacobian_threshold_lid_curve all_callbacks.monitor_lid1.subsample_size=128 +callbacks@all_callbacks.monitor_lid2=fast_flow_lidl_curve all_callbacks.monitor_lid2.subsample_size=128</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Obviously, we cannot stack LID estimators that use a different underlying model. For example, you cannot stack the Jacobian threshold estimator with the normal bundle estimator or any of the estimtors with the LIDL estimator.</p>
</section>
</section>
<section id="model-based-estimators-using-python-sdk" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="model-based-estimators-using-python-sdk"><span class="header-section-number">3</span> Model-based Estimators (using python SDK)</h2>
<p>Apart from using scripts, you may also use our LID estimators in your own code. Everything related to LID is stored in <code>lid/</code> directory. The LID estimators all inherit the <code>LIDEstimator</code> class that has an <code>estiamte_lid</code> function that takes in a batch of datapoints and returns their LID estimates. Here, we include a simple example of using the closed-form diffusion (CFDM) estimator and the fast flow LIDL estimator on the Lollipop dataset.</p>
<div id="cell-fig-lollipop" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization.pretty <span class="im">import</span> ColorTheme</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> data.datasets.generated <span class="im">import</span> LIDSyntheticDataset</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> data.distributions <span class="im">import</span> Lollipop</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>dset <span class="op">=</span> LIDSyntheticDataset(</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    size<span class="op">=</span><span class="dv">10000</span>,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    distribution<span class="op">=</span>Lollipop(),</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    seed<span class="op">=</span><span class="dv">42</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>plt.scatter(<span class="op">*</span>dset.x.T, color<span class="op">=</span>ColorTheme.GOLD.value)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-lollipop" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lollipop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="lid_guide_files/figure-html/fig-lollipop-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lollipop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: The lollipop dataset loaded.
</figcaption>
</figure>
</div>
</div>
</div>
<section id="a-model-free-estimator" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="a-model-free-estimator"><span class="header-section-number">3.1</span> A model-free estimator</h3>
<div id="cell-20" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lid.diffusions <span class="im">import</span> CFDM_LID</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1 <span class="im">import</span> make_axes_locatable</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co"># instantiate the lid_estimator</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>lid_estimator <span class="op">=</span> CFDM_LID(</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>dset.x,</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    ambient_dim<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device,</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    beta_min<span class="op">=</span> <span class="fl">0.1</span>,</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    beta_max<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    t_max<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>dset.x</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>t_values<span class="op">=</span>np.linspace(<span class="fl">1e-6</span>, <span class="dv">1</span>, <span class="dv">16</span>)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">12</span>))</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="co"># fig, axes = plt.subplots(1, 2, figsize=(16, 16))</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">len</span>(t_values) <span class="op">==</span> <span class="bu">len</span>(axes.flatten())</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, t <span class="kw">in</span> tqdm(</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">zip</span>(axes.flatten(), t_values),</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    desc<span class="op">=</span><span class="st">"computing scatterplots"</span>,</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    total<span class="op">=</span><span class="bu">len</span>(t_values),</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>):  <span class="co"># Generate 1k points and plot them</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    all_lid <span class="op">=</span> lid_estimator.estimate_lid(</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>        data, t<span class="op">=</span>t,</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    ).cpu()</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># clip LID values</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    all_lid <span class="op">=</span> np.clip(all_lid, <span class="dv">0</span>, lid_estimator.ambient_dim)</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> ax.scatter(<span class="op">*</span>data.cpu().T, c<span class="op">=</span>all_lid, cmap<span class="op">=</span><span class="st">"plasma"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"t=</span><span class="sc">{</span><span class="bu">round</span>(t, <span class="dv">3</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    divider <span class="op">=</span> make_axes_locatable(ax)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    cax <span class="op">=</span> divider.append_axes(<span class="st">"right"</span>, size<span class="op">=</span><span class="st">"5%"</span>, pad<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>    cbar <span class="op">=</span> fig.colorbar(s, cax<span class="op">=</span>cax, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    cbar.set_label(<span class="ss">f"$LID(</span><span class="ch">{{</span><span class="sc">{</span><span class="bu">round</span>(t, <span class="dv">2</span>)<span class="sc">}</span><span class="ch">}}</span><span class="ss">)(</span><span class="ch">\\</span><span class="ss">cdot)$"</span>, rotation<span class="op">=</span><span class="dv">90</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>fig.tight_layout(pad<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="lid_guide_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
<figcaption>The LID estimates of the lollipop dataset using the closed form diffusion estimator. The LID estimator has a hyperparameter <span class="math inline">t</span> that controls the scale of the diffusion. The LID estimates are shown for different values of <span class="math inline">t</span> and a certain value of <span class="math inline">t=0.067</span> seems to be able to separate the lollipop from the stick.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="a-model-based-estimator" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="a-model-based-estimator"><span class="header-section-number">3.2</span> A Model-based estimator</h3>
<p>First, train a normalizing flow on the lollipop dataset:</p>
<div id="cell-22" class="cell" data-execution_count="39">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> models.flows.training <span class="im">import</span> LightningFlow</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> models.training <span class="im">import</span> LightweightTrainer</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch <span class="im">import</span> optim</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nflows.flows.base <span class="im">import</span> Flow</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nflows.distributions <span class="im">import</span> StandardNormal</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> models.flows.diffeomorphisms <span class="im">import</span> RQNSF</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>flow_model <span class="op">=</span> Flow(</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  transform<span class="op">=</span>RQNSF(</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    dim<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    n_hidden<span class="op">=</span><span class="dv">64</span>, </span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    n_blocks<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    tails<span class="op">=</span><span class="st">"linear"</span>,</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    num_bins<span class="op">=</span><span class="dv">32</span>,</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    tail_bound<span class="op">=</span><span class="fl">10.0</span>,</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    data_type<span class="op">=</span><span class="st">"tabular"</span>,</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    n_transforms<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    include_actnorm<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  distribution<span class="op">=</span>StandardNormal(shape<span class="op">=</span>[<span class="dv">2</span>]),  </span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>training_module <span class="op">=</span> LightningFlow(</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    normalizing_flow<span class="op">=</span>flow_model,</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    optim_partial<span class="op">=</span>partial(optim.Adam, lr<span class="op">=</span><span class="fl">1e-4</span>),</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>trainer <span class="op">=</span> LightweightTrainer(</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    max_epochs<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device,</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>trainer.fit(</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>training_module,</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    train_dataloader<span class="op">=</span>torch.utils.data.DataLoader(dset.x.to(device), batch_size<span class="op">=</span><span class="dv">128</span>),</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    ckpt_path<span class="op">=</span><span class="st">'outputs/notebooks/lollipop-flow/'</span>,</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>gen_samples <span class="op">=</span> training_module.sample(<span class="dv">128</span>)</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization <span class="im">import</span> visualize_umap_clusters</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> visualization.pretty <span class="im">import</span> ColorTheme</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>visualize_umap_clusters(</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> [gen_samples.cpu().detach().numpy(), dset.x[:<span class="dv">1000</span>].cpu().numpy()],</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>[<span class="st">"generated"</span>, <span class="st">"real"</span>],</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"quality of model"</span>,</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="fl">0.3</span>,</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>    colors<span class="op">=</span>[ColorTheme.GOLD.value, ColorTheme.BLUE_SECOND.value],</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>    return_img<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a><span class="co"># The expected loss: &lt; 0.71</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="lid_guide_files/figure-html/cell-9-output-1.png" class="img-fluid figure-img"></p>
<figcaption>Training a flow model on lollipop and then generating the samples for evaluation. The samples are aligned with the original data, showing that the model has learned the distribution of the lollipop dataset.</figcaption>
</figure>
</div>
</div>
</div>
<p>Now let’s estimate LID. Again, we have a hyperparametr for scale.</p>
<div id="cell-24" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The LID estimates of the lollipop dataset using the fast LIDL estimator. The LID estimator has a hyperparameter $\delta$ that controls the scale of the estimator. The LID estimates are shown for different values of $\delta$ and a certain value of $\delta=-4.2$ seems to be able to separate the lollipop from the stick."</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.axes_grid1 <span class="im">import</span> make_axes_locatable</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lid.flows <span class="im">import</span> FastFlowLIDL</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>lid_estimator_flow <span class="op">=</span> FastFlowLIDL(</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>flow_model,</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    device<span class="op">=</span>device,</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>dset.x</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>delta_values<span class="op">=</span>np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">16</span>)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">12</span>))</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co"># fig, axes = plt.subplots(1, 2, figsize=(16, 16))</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">len</span>(t_values) <span class="op">==</span> <span class="bu">len</span>(axes.flatten())</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>iterator <span class="op">=</span> tqdm(</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">zip</span>(axes.flatten(), delta_values),</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    desc<span class="op">=</span><span class="st">"computing scatterplots"</span>,</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    total<span class="op">=</span><span class="bu">len</span>(delta_values),</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, delta <span class="kw">in</span> iterator:  <span class="co"># Generate 1k points and plot them</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    all_lid <span class="op">=</span> []</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> batch_idx, data_batch <span class="kw">in</span> <span class="bu">enumerate</span>(torch.split(data, <span class="dv">128</span>)):</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        all_lid.append(lid_estimator_flow.estimate_lid(data_batch, delta<span class="op">=</span>delta).cpu())</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        iterator.set_postfix({<span class="st">"batch"</span>: <span class="ss">f"[</span><span class="sc">{</span>batch_idx<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="bu">len</span>(data)<span class="op">//</span><span class="dv">128</span><span class="sc">}</span><span class="ss">]"</span>})</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    all_lid <span class="op">=</span> torch.cat(all_lid)</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># clip LID values</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    all_lid <span class="op">=</span> np.clip(all_lid, <span class="dv">0</span>, lid_estimator.ambient_dim)</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> ax.scatter(<span class="op">*</span>data.cpu().T, c<span class="op">=</span>all_lid, cmap<span class="op">=</span><span class="st">"plasma"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"$</span><span class="ch">\\</span><span class="ss">delta$=</span><span class="sc">{</span><span class="bu">round</span>(delta, <span class="dv">3</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    divider <span class="op">=</span> make_axes_locatable(ax)</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    cax <span class="op">=</span> divider.append_axes(<span class="st">"right"</span>, size<span class="op">=</span><span class="st">"5%"</span>, pad<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    cbar <span class="op">=</span> fig.colorbar(s, cax<span class="op">=</span>cax, orientation<span class="op">=</span><span class="st">"vertical"</span>)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    cbar.set_label(<span class="ss">f"$LID(</span><span class="ch">{{</span><span class="sc">{</span><span class="bu">round</span>(delta, <span class="dv">2</span>)<span class="sc">}</span><span class="ch">}}</span><span class="ss">)(</span><span class="ch">\\</span><span class="ss">cdot)$"</span>, rotation<span class="op">=</span><span class="dv">90</span>, labelpad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>fig.tight_layout(pad<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>computing scatterplots: 100%|██████████| 16/16 [03:33&lt;00:00, 13.32s/it, batch=[78/78]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lid_guide_files/figure-html/cell-10-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<!-- 
## References -->
<!-- 
::: {#refs}
::: -->



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-kamkari2024oodlid" class="csl-entry" role="listitem">
Kamkari, Hamidreza, Brendan Leigh Ross, Jesse C Cresswell, Anthony L Caterini, Rahul G Krishnan, and Gabriel Loaiza-Ganem. 2024. <span>“A Geometric Explanation of the Likelihood OOD Detection Paradox.”</span> <em>arXiv Preprint arXiv:2403.18910</em>.
</div>
<div id="ref-kamkari2024flipd" class="csl-entry" role="listitem">
Kamkari, Hamidreza, Brendan Leigh Ross, Rasa Hosseinzadeh, Jesse C Cresswell, and Gabriel Loaiza-Ganem. 2024. <span>“A Geometric View of Data Complexity: Efficient Local Intrinsic Dimension Estimation with Diffusion Models.”</span> <em>arXiv Preprint arXiv:2406.03537</em>.
</div>
<div id="ref-stanczuk2022your" class="csl-entry" role="listitem">
Stanczuk, Jan, Georgios Batzolis, Teo Deveney, and Carola-Bibiane Schönlieb. 2022. <span>“Your Diffusion Model Secretly Knows the Dimension of the Data Manifold.”</span> <em>arXiv:2212.12611</em>.
</div>
<div id="ref-tempczyk2022lidl" class="csl-entry" role="listitem">
Tempczyk, Piotr, Rafał Michaluk, Lukasz Garncarek, Przemysław Spurek, Jacek Tabor, and Adam Golinski. 2022. <span>“<span class="nocase">LIDL: Local intrinsic dimension estimation using approximate likelihood</span>.”</span> In <em>International Conference on Machine Learning</em>, 21205–31.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>